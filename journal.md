# Journal de bord du projet encadré
## 02 Exercice : création d'un dépôt et journal github
J'ai créé un dépôt personnel GitHub pour le cours Programmation et Projet Encadré 1 avant de le cloner sur mon ordinateur. Ayant désormais deux dépôts nommés PPE1-2024 (celui du professeur, cloné lors du dernier cours, et le mien) j'ai créé un dossier où stocker le nouveau. Mon journal a aussi été généré et modifié avec succès. Je m'attelle désormais à sa synchronisation. Synchronisation réussie à l'aide de la commande `git pull`. Je vais maintenant ajouter un tag avec `git tag [-a] [-m message]` et `git push origin`. Ceci est la dernière version du journal.  

**Problème :** Rien à signaler.

## 03 Exercice : correction d'erreurs
(Cette ligne doit rester après correction.
Je suis à l'exercice 3 de l'exercice sur comment corriger ses erreurs git. De ce que j'ai compris ce fichier oups.md va disparaître avant la fin de l'exercice et ces modifications apportées seront intégrées au fichier journal.md.
Je vais mettre de côté cette ligne pour l'exercice 4.a.)  

Pour répondre aux questions posées lors de l'exercice sur comment défaire un commit ou des modifications, j'ai pu remarquer dans la première méthode, en utilisant `git revert`, que le commit I AM ERROR, même défait, apparait toujours dans mon historique de commit (`git log`) , alors qu'en utilisant la commande `git reset --soft HEAD^`, mon commit disparait bien. Le seul élément que ces deux commandes ont en commun est la création d'un nouveau commit contenant les corrections apportées.  
Ensuite, pour voir si la version de mon dépôt local est à jour avec celle en ligne, j'utilise la commande `git fetch` qui récupère les données de la version en ligne, puis `git status` qui compare ce qui a été récupéré de la version en ligne à la version locale et qui m'indique si je suis en retard. Lorsque j'essaie de récupérer ces modifications avec la commande `git pull`, le terminal affiche une erreur et que les changements locaux seront écrasés. Il faut donc d'abord que je commit mes changements ou que je les stash avant de les merge. Pour sauvegarder ces changements dans un coin, j'utilise alors la commande `git stash push -m`, puis `git stash list` pour afficher l'index du stash et `git show <stash>` en renseignant l'index pour pouvoir afficher les changements. Une fois avoir récupéré la version en ligne `git pull` et lui avoir appliqué les modifications `git stash apply <stash>`, je peux supprimer le stash grâce à la commande `git stash drop <stash>`.

**Problème :** Dans l'exercice 3.a, lorsqu'il s'agissait de conserver les changements de oups.md tout en revenant sur un ancien commit, j'ai d'abord cru qu'il fallait utiliser la commande `git stash push` mais j'ai pensé qu'après avoir appliqué les modifications, je me retrouverais toujours avec les commit journal.md et oups.md. Une fois revenue sur la bonne piste en réalisant que si j'ajoutais l'option `--soft` à la commande `git reset`, je pouvais conserver les modifications de oups.md puis les copier manuellement sur le terminal dans journal.md, je n'ai plus rencontré de problème par la suite.

## 03 Exercice : pipelines
La première question que je me suis posée en commençant cet exercice était ce qu'on entend exactement par "annotation". Après avoir compris en classe qu'il s'agit de chaque ligne dans un fichier .ann, l'exercice m'a tout de suite paru plus simple et réalisable. La prochaine difficulté rencontrée concernait le chevron > qui écrase le contenu d'un fichier si les commandes ne peuvent être écrites sur une seule ligne. Mais je me suis ensuite rappelée qu'en le doublant >>, je pouvais ajouter du contenu sans effacer l'ancien. J'ai ensuite utilisé l'option `-l` après la commande `wc` pour garder uniquement le nombre de lignes (occurrences) de chaque annotation. Ayant trouvé sur internet que la commande `uniq` nécessite que les éléments soient triés au préalable, j'ai utilisé la commande `sort -n` avant et après pour trier les annotations en fonction de leur nombre d'occurrences. La réalisation de cet exercice a été relativement fluide, je n'ai pas rencontré de problème majeur bloquant ma progression bien que j'en ressors avec deux questionnements.

**Problèmes :** Dans mes fichiers de classements, à chaque début de ligne on dirait qu'il y a un tab, ainsi je me demande si je n'aurais pas dû rajouter une option sur la commande `cut -f 3` pour que le tab soit supprimé, mais je ne suis pas certaine que l'erreur vienne de là.  
De plus, en effectuant l'exercice, je me suis demandée plusieurs fois s'il n'y avait pas une manière plus simple d'agir sur des fichiers et dossiers à partir du terminal sans directement se placer dans le chemin en question. Pour faciliter la tâche et ne pas avoir à changer de chemin à chaque fois, j'ai déplacé mon dossier ann directement dans le dossier Exercices de mon dépôt local. De cette façon, je n'ai eu qu'à ajouter la branche du chemin ann/ pour lire le contenu d'un fichier, mais je me demande s'il n'existe pas d'autres façons de faire pour que l'ordinateur retrouve lui-même le fichier sans qu'on doive lui indiquer le chemin.

## 04 Exercice : script bash
Le script bash donné dans le cours semble vérifier si des URLs sont valides ou non. Il demande un argument `$1` qui correspond à un fichier contenant plusieurs URLs que l'on souhaite tester. Les premières lignes du script dont la condition `if [ $# -ne 1 ]` (littéralement : si $# n'est pas égal à 1), servent à préciser à l'utilisateur que le programme nécéssite un argument pour fonctionner en affichant un message avec la commande `echo`. La ligne de commande `while read -r LINE;` crée une boucle dans laquelle chaque ligne du fichier est lue et stockée dans la variable `LINE`. L'option `-r` permet d'ignorer les caractères spéciaux comme les backslashes `\`.  
Par la suite, le script pose une condition : `if [[ $LINE =~ ^https?:// ]]`. Si la ligne (URL) commence en début de ligne `^` par http:// ou https://, le programme ajoute une occurrence dans la variable `OK` et affiche un message de confirmation avec la commande `echo`. Sinon, si la ligne (URL) ne remplit pas cette condition, une occurrence est ajoutée cette fois-ci dans la variable `NOK`, et un message s'affiche avec la commande `echo` pour prévenir l'utilisateur. À la fin, ce script donne les comptes, respectivement stockés dans les variables `OK` et `NOK`, des URLs correctes et incorrectes du fichier.  

**Problème :** Rien à signaler.  
  
## 05 Exercice : mini projet  
Dans le script, on utilise `while read` au lieu de `cat` car lorsqu'on utilise `read`, chaque ligne est lue directement sans avoir à charger tout le fichier en entier contrairement à `cat`. Pour une boucle qui agit sur de larges fichiers, utiliser `read` est plus approprié.  
Pour que les tabulations et l'ordre dans lequel s'affichent mes variables soient respectés, j'ai rajouter les commandes `tr -d '\n'` et `tr -d '\r'` pour que les retours à la ligne et retours chariot présents dans les informations que récupère `curl` soient supprimés et ne perturbent pas l'affichage de mon tableau.
J'ai utilisé principalement les options `-o, -s, -i, w` de la commande `curl` dans mon script. L'option `-o` permet d'enregistrer la réponse obtenue après la requête HTTP dans un fichier de sortie, ici pour se débarrasser du contenu de la requête, autre que le code HTTP. L'option `-s` permet d'afficher uniquement le code d'erreur et non les messages d'erreur ou autres informations concernant la requête HTTP. L'option `-i` permet d'afficher les entêtes HTTP dans la réponse que `curl` récupère, dont `Content-Type` pour récupérer l'encodage de la page. L'option `-w` permet de spécifier un format de sortie, ici c'est-à-dire d'afficher le code HTTP.  
  
**Problème :** Rien à signaler.  
